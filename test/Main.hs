module Main where
import Test.Framework
import Test.Framework.Providers.HUnit
import Test.HUnit
import qualified Data.Set as Set
import qualified Anatree as Anatree

tests :: [Test.Framework.Test]
tests = hUnitTestToTests $ TestList [
  let t = Anatree.fromList [] :: Anatree.Tree Char
  in "[]" ~: Test.HUnit.TestList [
  "size"            ~: 0     ~=? (Anatree.size t),
  "null"            ~: True  ~=? (Anatree.null t),
  "treeSize"        ~: 1     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList []) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ba" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: [] ~=? (Anatree.toList t),
  "toAscList"       ~: [] ~=? (Anatree.toAscList t),
  "toDescList"      ~: [] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList []) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: [] ~=? (Anatree.foldMap (replicate 2) t),
  "show"            ~: "Leaf (fromList [])" ~=? (show t)
  ],
  let t = Anatree.singleton ""
  in "['']" ~: Test.HUnit.TestList [
  "size"            ~: 1     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 1     ~=? (Anatree.treeSize t),
  "member ''"       ~: True  ~=? (Anatree.member "" t),
  "notMember ''"    ~: False ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList [""]) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList []) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])   ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList [""]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])   ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList [""]) ~=? (Anatree.subanagrams "ba" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])   ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList [""]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: [""] ~=? (Anatree.toList t),
  "toAscList"       ~: [""] ~=? (Anatree.toAscList t),
  "toDescList"      ~: [""] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList [""]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["", ""] ~=? (Anatree.foldMap (replicate 2) t),
  "show"            ~: "Leaf (fromList [\"\"])" ~=? (show t)
  ],
  -- Tests with a single 'a' node [2]
  let t = Anatree.singleton "a"
  in "['a']" ~: Test.HUnit.TestList [
  "size"            ~: 1     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 3     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ba" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["a"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["a"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["a"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["a"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["a", "a"] ~=? (Anatree.foldMap (replicate 2) t),
  "show"            ~: "Node (fromList []) 'a' (Leaf (fromList [])) (Leaf (fromList [\"a\"]))" ~=? (show t)
  ],
  let t = Anatree.fromList ["a", "a"]
  in "['a','a']" ~: Test.HUnit.TestList [
  "size"            ~: 1     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 3     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ba" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["a"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["a"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["a"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["a"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["a", "a"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromSet (Set.fromAscList ["", "a"])
  in "['','a']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 3     ~=? (Anatree.treeSize t),
  "member ''"       ~: True  ~=? (Anatree.member "" t),
  "notMember ''"    ~: False ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList [""]) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])        ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["", "a"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])        ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["", "a"]) ~=? (Anatree.subanagrams "ba" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])        ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["", "a"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["", "a"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["", "a"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["a", ""] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["", "a"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["", "", "a", "a"] ~=? (Anatree.foldMap (replicate 2) t),
  "show"            ~: "Node (fromList [\"\"]) 'a' (Leaf (fromList [])) (Leaf (fromList [\"a\"]))" ~=? (show t)
  ],
  -- Tests with a single 'b' node [2]
  let t = Anatree.singleton "b"
  in "['b']" ~: Test.HUnit.TestList [
  "size"            ~: 1     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 3     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["b"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["b"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b"] ~=? (Anatree.foldMap (replicate 2) t),
  "show"            ~: "Node (fromList []) 'b' (Leaf (fromList [])) (Leaf (fromList [\"b\"]))" ~=? (show t)
  ],
  -- Tests with an 'a,b' chain [2]
  let t = Anatree.fromList ["a", "b"]
  in "['a','b']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 5     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a", "b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])         ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["a", "b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])         ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["a", "b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b", "a"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["a", "b"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["b", "a"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["a", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b", "a", "a"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["b", "a"]
  in "['b','a']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 5     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a", "b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])         ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["a", "b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])         ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["a", "b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList []) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b", "a"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["a", "b"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["b", "a"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["a", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b", "a", "a"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["ab", "ba"]
  in "['ab','ba']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 5     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList []) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: True  ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: True  ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ab"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["ab", "ba"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["ab", "ba"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ba", "ab"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["ab", "ab", "ba", "ba"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["ba", "ab"]
  in "['ba','ab']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 5     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList []) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: True  ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: True  ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ab"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["ab", "ba"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["ab", "ba"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ba", "ab"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["ab", "ba"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["ab", "ab", "ba", "ba"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["a", "ab", "a"]
  in "['a','ab','a']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 5     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: True  ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ab"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["a", "ab"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ab"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["a", "ab"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])    ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["a"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ab"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["a", "ab"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["a", "ab"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ab", "a"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["a", "ab"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["a", "a", "ab", "ab"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  -- Tests with one 'a' node and two 'b' nodes.
  let t = Anatree.fromList ["b", "ab"]
  in "['b','ab']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: True  ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ab"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["b", "ab"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ab"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["b", "ab"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ab"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b", "ab"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["ab", "b"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["b", "ab"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["ab", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b", "ab", "ab"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["b", "ba"]
  in "['b','ba']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ba"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["b", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: True  ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ba"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["b", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ba"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b", "ba"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["b", "ba"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ba", "b"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["ba", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b", "ba", "ba"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["b", "ab", "b"]
  in "['b','ab','b']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: True  ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ab"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["b", "ab"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ab"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["b", "ab"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ab"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b", "ab"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["ab", "b"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["b", "ab"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["ab", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b", "ab", "ab"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["b", "ab", "ba"]
  in "['b','ab','ba']" ~: Test.HUnit.TestList [
  "size"            ~: 3     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: True  ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ab", "ba"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["b", "ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: True  ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ab", "ba"])      ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["b", "ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList []) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList []) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ab"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b", "ab", "ba"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["ab", "b", "ba"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ba", "b", "ab"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["ab", "ba", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b", "ab", "ab", "ba", "ba"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["b", "ab", "a", "ba", ""]
  in "['b','ab','a','ba','']" ~: Test.HUnit.TestList [
  "size"            ~: 5     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: True  ~=? (Anatree.member "" t),
  "notMember ''"    ~: False ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList [""]) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a", "b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: True  ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ab", "ba"])               ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["", "a", "b", "ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: True  ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ab", "ba"])               ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["", "a", "b", "ab", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: False ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList [])        ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["", "a"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ab"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["", "b", "a", "ab", "ba"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["", "a", "ab", "b", "ba"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ba", "b", "ab", "a", ""] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["", "a", "ab", "ba", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["", "", "b", "b", "a", "a", "ab", "ab", "ba", "ba"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  -- An 'abc' chain.
  let t = Anatree.fromList ["ac", "ba"]
  in "['ac','ba']" ~: Test.HUnit.TestList [
  "size"            ~: 2     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: False ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: True  ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList []) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: True  ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: True  ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList ["ac"]) ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["ac"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ba","ac"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["ac", "ba"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["ac", "ba"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ba", "ac"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["ba", "ac"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["ac", "ac", "ba", "ba"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  let t = Anatree.fromList ["ac", "a", "ba"]
  in "['ac','a','ba']" ~: Test.HUnit.TestList [
  "size"            ~: 3     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: False ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: True  ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList ["ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["a", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: True  ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList ["ba"]) ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["a", "ba"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: True  ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList ["ac"])      ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["a", "ac"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ba","ac"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["a", "ac", "ba"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["a", "ac", "ba"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["ba", "ac", "a"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["a", "ba", "ac"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["a", "a", "ac", "ac", "ba", "ba"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  -- Tree with a common 'a' node and then splitting into 'b' and 'c' subtrees
  let t = Anatree.fromList ["ac", "b", "a"]
  in "['ac','b','a']" ~: Test.HUnit.TestList [
  "size"            ~: 3     ~=? (Anatree.size t),
  "null"            ~: False ~=? (Anatree.null t),
  "treeSize"        ~: 7     ~=? (Anatree.treeSize t),
  "member ''"       ~: False ~=? (Anatree.member "" t),
  "notMember ''"    ~: True  ~=? (Anatree.notMember "" t),
  "keys 0"          ~: (Set.fromList []) ~=? (Anatree.keys 0 t),
  "member 'a'"      ~: True  ~=? (Anatree.member "a" t),
  "notMember 'a'"   ~: False ~=? (Anatree.notMember "a" t),
  "member 'b'"      ~: True  ~=? (Anatree.member "b" t),
  "notMember 'b'"   ~: False ~=? (Anatree.notMember "b" t),
  "keys 1"          ~: (Set.fromList ["a", "b"]) ~=? (Anatree.keys 1 t),
  "member 'ab'"     ~: False ~=? (Anatree.member "ab" t),
  "anagram 'ab'"    ~: (Set.fromList [])         ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ab'" ~: (Set.fromList ["a", "b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ba'"     ~: False ~=? (Anatree.member "ba" t),
  "anagram 'ba'"    ~: (Set.fromList [])         ~=? (Anatree.anagrams "ab" t),
  "subanagram 'ba'" ~: (Set.fromList ["a", "b"]) ~=? (Anatree.subanagrams "ab" t),
  "member 'ac'"     ~: True  ~=? (Anatree.member "ac" t),
  "anagram 'ac'"    ~: (Set.fromList ["ac"])      ~=? (Anatree.anagrams "ac" t),
  "subanagram 'ac'" ~: (Set.fromList ["a", "ac"]) ~=? (Anatree.subanagrams "ac" t),
  "keys 2"          ~: (Set.fromList ["ac"]) ~=? (Anatree.keys 2 t),
  "toList"          ~: ["b", "a", "ac"] ~=? (Anatree.toList t),
  "toAscList"       ~: ["a", "ac", "b"] ~=? (Anatree.toAscList t),
  "toDescList"      ~: ["b", "ac", "a"] ~=? (Anatree.toDescList t),
  "toSet"           ~: (Set.fromList ["a", "ac", "b"]) ~=? (Anatree.toSet t),
  "foldr"           ~: (Anatree.toList t)           ~=? (Anatree.foldr (:) [] t),
  "foldl"           ~: (reverse $ Anatree.toList t) ~=? (Anatree.foldl (flip (:)) [] t),
  "foldMap"         ~: ["b", "b", "a", "a", "ac", "ac"] ~=? (Anatree.foldMap (replicate 2) t)
  ],
  -- Equality Checking
  "Eq (==) (/=)" ~: Test.HUnit.TestList [
      -- Matches
      "[''] == ['']"             ~: True ~=? (Anatree.singleton ""         == Anatree.singleton ""),
      "['a'] == ['a']"           ~: True ~=? (Anatree.singleton "a"        == Anatree.singleton "a"),
      "['a', 'b'] == ['b', 'a']" ~: True ~=? (Anatree.fromList ["a", "b"]  == Anatree.fromList ["b", "a"]),
      -- Mismatches: Leaf vs. Node
      "[] /= ['']"               ~: True ~=? (Anatree.singleton ""         /= Anatree.empty),
      "[] /= ['']"               ~: True ~=? (Anatree.empty                /= Anatree.singleton ""),
      "['']  /= ['a']"           ~: True ~=? (Anatree.singleton ""         /= Anatree.singleton "a"),
      "['a'] /= ['']"            ~: True ~=? (Anatree.singleton "a"        /= Anatree.singleton ""),
      -- Mismatches Node ws _ _  _
      "['', 'a'] /= ['a']"       ~: True ~=? (Anatree.fromList ["", "a"]   /= Anatree.singleton "a"),
      "['b'] /= ['b', '']"       ~: True ~=? (Anatree.fromList ["b"]       /= Anatree.fromList ["b", ""]),
      -- Mismatches: Node _ c _  _
      "['b'] /= ['a']"           ~: True ~=? (Anatree.singleton "b"        /= Anatree.singleton "a"),
      -- Mismatches: Node _ _ t0 _
      "['a', 'b'] /= ['a']"      ~: True ~=? (Anatree.fromList ["a", "b"]  /= Anatree.singleton "a"),
      "['a'] /= ['a', 'b']"      ~: True ~=? (Anatree.fromList ["a"]       /= Anatree.fromList ["a", "b"]),
      -- Mismatches: Node _ _ _  t1
      "['a', 'ab'] /= ['a']"     ~: True ~=? (Anatree.fromList ["a", "ab"] /= Anatree.singleton "a"),
      "['a'] /= ['a', 'ab']"     ~: True ~=? (Anatree.singleton "a"        /= Anatree.fromList ["a", "ab"])
  ],
  -- Union
  let empty = Anatree.empty :: Anatree.Tree Char
      eps   = Anatree.singleton ""
      a     = Anatree.singleton "a"
      b     = Anatree.singleton "b"
      ab    = Anatree.singleton "ab"
      ba    = Anatree.singleton "ba"
      ac    = Anatree.singleton "ac"
  in "union" ~: Test.HUnit.TestList [
      -- Merges in leaf (root)
      "[] U []"         ~: empty ~=? Anatree.union empty empty,
      "[''] U []"       ~: eps   ~=? Anatree.union eps empty,
      "[] U ['']"       ~: eps   ~=? Anatree.union empty eps,
      "[''] U ['']"     ~: eps   ~=? Anatree.union eps eps,
      -- Merges in leaf (after node)
      "['a'] U []"      ~: a     ~=? Anatree.union a empty,
      "[] U ['a']"      ~: a     ~=? Anatree.union empty a,
      "['a'] U ['a']"   ~: a     ~=? Anatree.union a a,
      "['b'] U []"      ~: b     ~=? Anatree.union b empty,
      "[] b ['b']"      ~: b     ~=? Anatree.union empty b,
      "['b'] U ['b']"   ~: b     ~=? Anatree.union b b,
      "['ab'] U ['ba']" ~: Anatree.fromList ["ab", "ba"] ~=? Anatree.union ab ba,
      "['ba'] U ['ab']" ~: Anatree.fromList ["ab", "ba"] ~=? Anatree.union ba ab,
      -- Merge in node (left early)
      "['a'] U ['b']"   ~: Anatree.fromList ["a", "b"]   ~=? Anatree.union a b,
      "['ab'] U ['ac']" ~: Anatree.fromList ["ab", "ac"] ~=? Anatree.union ab ac,
      -- Merge in node (right early)
      "['b'] U ['a']"   ~: Anatree.fromList ["a", "b"]   ~=? Anatree.union b a,
      "['ac'] U ['ab']" ~: Anatree.fromList ["ab", "ac"] ~=? Anatree.union ac ab,
      -- Merge in node (match)
      "['a'] U ['ab']"  ~: Anatree.fromList ["a", "ab"] ~=? Anatree.union a ab,
      "['ab'] U ['a']"  ~: Anatree.fromList ["a", "ab"] ~=? Anatree.union ab a,
      "([''] U ['ab']) U (['a'] U ['b'])" ~:
        Anatree.fromList ["", "a", "b", "ab"] ~=? Anatree.union (Anatree.union eps ab)
                                                                (Anatree.union a   b)
  ],
  let empty = Anatree.empty :: Anatree.Tree Char
      eps   = Anatree.singleton ""
      a     = Anatree.singleton "a"
      b     = Anatree.singleton "b"
      ab    = Anatree.singleton "ab"
  in "unions" ~: Test.HUnit.TestList [
    "[]"               ~: empty                             ~=? Anatree.unions [],
    "['']"             ~: Anatree.fromList [""]             ~=? Anatree.unions [eps],
    "['a']"            ~: Anatree.fromList ["a"]            ~=? Anatree.unions [a],
    "['a', 'b']"       ~: Anatree.fromList ["a", "b"]       ~=? Anatree.unions [a, b],
    "['b', 'a']"       ~: Anatree.fromList ["a", "b"]       ~=? Anatree.unions [b, a],
    "['b', 'a', 'ab']" ~: Anatree.fromList ["a", "b", "ab"] ~=? Anatree.unions [b, a, ab]
  ]
  ]

main :: IO ()
main = defaultMain tests
